/* eslint no-console: 0*/
'use strict';

const {v4: uuid} = require('uuid');
const lib = require('@sap/hdi-deploy/library.js');
const Logger = require('./logger');
const parse_request_body = require('./parameter_parser');
const {get_audit_logging_service_if_bound, AuditLogger} = require('./auditlogging.js');
const IO = require('./io');
/**
 * Function used for the /deploy API endpoint.
 *
 * @param {Request} req Request
 * @param {Response} res Response
 *
 * @returns {undefined}
 */
function deployCB(req, res) {
  req.setTimeout(0);
  const dynamic_deployer_logger = new Logger();
  const deployerEnv = parse_request_body(req.body, dynamic_deployer_logger);

  dynamic_deployer_logger.log('Starting deployment...');
  const start = process.hrtime();
  const io = new IO();

  const timer = setInterval(() => res.write('\n'), 120000);
  lib.deploy(process.cwd(), deployerEnv, function (e, response) {
    clearInterval(timer);
    if (e) {
      res.status(500).send(`Starting the deployer encountered an error: ${e.message ? e.message : e}`);
    } else {
      const deploymentTime = process.hrtime(start)[1];
      dynamic_deployer_logger.log(`Finished deployment in ${Math.trunc(deploymentTime / 1000000)} ms.`);
      response.dynamic_deployer_log = dynamic_deployer_logger.get_messages();
      res.end(JSON.stringify(response, null, 2));
    }
  }, {
    stdoutCB: (m) => { m = m.toString('utf8'); io.log(m); }, 
    stderrCB: (m) => { m = m.toString('utf8'); io.error(m); }
  });
}

/**
 * Function used for the /deploy/to/instance API endpoint.
 *
 * @param {Request} req Request
 * @param {Response} res Response
 *
 * @returns {undefined}
 */
function deployToInstanceCB(req, res) {
  if (typeof req.body.status === 'undefined') {
    res.status(400).send('missing "status" attribute in request body');
    return;
  } else if (req.body.status !== 'CREATION_SUCCEEDED') {
    res.status(400).send(`status of managed service instance is "${req.body.status}" but is expected to be "CREATION_SUCCEEDED"`);
    return;
  }

  if (typeof req.body.id === 'undefined') {
    res.status(400).send('missing "id" attribute in request body');
    return;
  }
  const id = req.body.id;

  if (typeof req.body.credentials === 'undefined') {
    res.status(400).send('missing "credentials" attribute in request body');
  } else {
    req.body = {
      TARGET_CONTAINER: id,
      ADDITIONAL_VCAP_SERVICES: {
        hana: [
          {
            name: id,
            label: 'hana',
            tags: ['hana', 'database', 'relational'],
            plan: 'hdi-shared',
            credentials: req.body.credentials
          }
        ]
      }
    };
    deployCB(req, res);
  }
}

const deployment_status = {
  RUNNING: 'RUNNING',
  FINISHED: 'FINISHED',
  FAILED: 'FAILED'
};

/**
 * Function used by the /deploy/to/instance/async API endpoint.
 *
 * Starts a deployment asynchronously and returns a guid to retrieve its status.
 *
 * @param {Request} req Request
 * @param {Response} res Response
 *
 * @returns {undefined}
 */
function deployAsync(req, res) {
  const dynamic_deployer_logger = new Logger();
  const deployerEnv = parse_request_body(req.body, dynamic_deployer_logger);
  const async_deployments = req.app.locals.async_deployments;
  const guid = uuid();
  const io = new IO();

  dynamic_deployer_logger.log(`Starting deployment ${guid}...`);

  let deployment = {
    guid: guid,
    start: process.hrtime(),
    duration: null,
    status: deployment_status.RUNNING,
    deployer_response: null
  };
  async_deployments.set(guid, deployment);

  lib.deploy(process.cwd(), deployerEnv, function (e, response) {
    deployment.duration = process.hrtime(deployment.start);
    const durationInSeconds = `${deployment.duration[0]}.${Math.trunc(deployment.duration[1] / 1e6)}`;

    if (e) {
      deployment.status = deployment_status.FAILED;
      dynamic_deployer_logger.log(`Starting the deployer for deployment ${guid} encountered an error: ${e.message ? e.message : e}`);
    } else if (response.exitCode !== 0) {
      deployment.status = deployment_status.FAILED;
      dynamic_deployer_logger.log(`Deployment ${guid} failed in ${durationInSeconds}s. See 'messages' for details.`);
    } else {
      deployment.status = deployment_status.FINISHED;
      dynamic_deployer_logger.log(`Finished deployment ${guid} in ${durationInSeconds}s.`);
    }

    deployment.deployer_response = response;
    deployment.deployer_response.dynamic_deployer_log = dynamic_deployer_logger.get_messages();
  }, {
    stdoutCB: (m) => { m = m.toString('utf8'); io.log(m); }, 
    stderrCB: (m) => { m = m.toString('utf8'); io.error(m); }
  });

  res.status(201).location('/status/' + guid).send({guid: guid});
}

/**
 * Function used for the /deploy/to/instance/async API endpoint.
 *
 * @param {Request} req Request
 * @param {Response} res Response
 *
 * @returns {undefined}
 */
function deployToInstanceAsyncCB(req, res) {
  if (typeof req.body.status === 'undefined') {
    res.status(400).send('missing "status" attribute in request body');
    return;
  } else if (req.body.status !== 'CREATION_SUCCEEDED') {
    res.status(400).send(`status of managed service instance is "${req.body.status}" but is expected to be "CREATION_SUCCEEDED"`);
    return;
  }

  if (typeof req.body.id === 'undefined') {
    res.status(400).send('missing "id" attribute in request body');
    return;
  }
  const id = req.body.id;

  if (typeof req.body.credentials === 'undefined') {
    res.status(400).send('missing "credentials" attribute in request body');
  } else {
    req.body = {
      TARGET_CONTAINER: id,
      ADDITIONAL_VCAP_SERVICES: {
        hana: [
          {
            name: id,
            label: 'hana',
            tags: ['hana', 'database', 'relational'],
            plan: 'hdi-shared',
            credentials: req.body.credentials
          }
        ]
      }
    };
    deployAsync(req, res);
  }
}

/**
 * Function used for the /status/{guid} API endpoint.
 *
 * @param {Request} req Request
 * @param {Response} res Response
 *
 * @returns {undefined}
 */
function statusCB(req, res) {
  if (typeof req.params.guid === 'undefined') {
    res.status(400).send('missing "guid" parameter in request url');
    return;
  }

  const async_deployments = req.app.locals.async_deployments;
  const guid = req.params.guid;

  if (async_deployments.has(guid)) {
    const deployment = async_deployments.get(guid);
    let response;

    if (deployment.status === deployment_status.RUNNING) {
      response = {status: deployment.status};
    } else {
      response = deployment.deployer_response;
      response.status = deployment.status;
    }

    res.status(200).send(response);
  } else {
    res.status(404).send(`Deployment with guid ${guid} does not exist.`);
  }
}

const express = require('express');
const app = express();

const basicAuth = require('express-basic-auth');
const users = {};
users[process.env.hdi_dynamic_deploy_user] = process.env.hdi_dynamic_deploy_password;

// Setup the auth middleware
const audit_log_service = get_audit_logging_service_if_bound();

const enforce_auditing = process.env.ENFORCE_AUDITING ? process.env.ENFORCE_AUDITING === 'TRUE' : false;

const audit_log_tenant = process.env.AUDIT_LOG_TENANT;

let audit_logger;

if (!audit_log_service && enforce_auditing) {
  throw new Error('No auditlog service was found but ENFORCE_AUDITING is TRUE. Make sure that the service is bound and is tagged with the tag "auditlog".');
} else if (audit_log_service) {
  audit_logger = new AuditLogger(audit_log_service, enforce_auditing, audit_log_tenant);
  app.use(basicAuth({
    users: users, unauthorizedResponse: (req) => {
      audit_logger.log_failed_login_attempt(req);
    }
  }));
  // Audit logger needs to be initialized, will be done in the ServerWrap
} else {
  app.use(basicAuth({users: users}));
}

const bodyParser = require('body-parser');
app.use(bodyParser.urlencoded({extended: true}));
app.use(bodyParser.json());

const DeploymentManager = require('./deployment_manager');
const deploymentManager = new DeploymentManager();
deploymentManager.scheduleCleanup();
app.locals.async_deployments = deploymentManager.deployments();

const v1api = express.Router();
v1api.route('/deploy').post(deployCB);
v1api.route('/deploy/to/instance').post(deployToInstanceCB);
v1api.route('/deploy/to/instance/async').post(deployToInstanceAsyncCB);
v1api.route('/status/:guid').get(statusCB);
app.use('/v1', v1api);

app.get('/', function (req, res) {
  res.end('This is the @sap/hdi-dynamic-deploy HTTP server. To trigger a deployment synchronously,' +
    ' send a suitable POST request to /v1/deploy or to /v1/deploy/to/instance.' +
    ' To trigger a deployment asynchronously, send a suitable POST request to /v1/deploy/to/instance/async,' +
    ' and a GET request to /v1/status/{guid} to retrieve the status of the asynchronous deployment.');
});

const ServerWrap = require('./ServerWrap');
const server_wrap = new ServerWrap(app, 0, audit_logger);

module.exports = {
  server: server_wrap,
  deploy_to_instance: deployToInstanceCB,
  deploy_to_instance_async: deployToInstanceAsyncCB,
  deploy: deployCB,
  status: statusCB
};
